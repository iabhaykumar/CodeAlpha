import React from 'react';
import { Topic } from './types';
import CodeBlock from '../../components/CodeBlock';

export const JAVASCRIPT_PART4_TOPICS: Topic[] = [
    // 15. Node.js
    {
        id: 'js-node-npm',
        title: 'npm & package.json',
        parent: '15. Node.js (Optional but Important)',
        content: (
            <>
                <p className="mb-4"><strong>npm (Node Package Manager)</strong> is the world's largest software registry. It's a command-line tool that comes with Node.js and is used to install and manage third-party packages (libraries) in your projects.</p>
                <p className="mb-4">The <strong>`package.json`</strong> file is the heart of any Node.js project. It records project metadata and, most importantly, the project's dependencies.</p>
                <CodeBlock language="bash" code={`# Initialize a new Node.js project
npm init -y

# Install a package (e.g., express) and save it to package.json
npm install express

# Install a development-only package (e.g., nodemon)
npm install --save-dev nodemon`} />
            </>
        )
    },
    {
        id: 'js-node-modules',
        title: 'Node modules',
        parent: '15. Node.js (Optional but Important)',
        content: (
            <p>When you run `npm install`, npm downloads the packages listed in `package.json` and puts them in a folder named `node_modules`. You typically don't commit this folder to version control; it can be regenerated by running `npm install` on any machine that has the `package.json` file.</p>
        )
    },
    {
        id: 'js-node-fs',
        title: 'File System (fs)',
        parent: '15. Node.js (Optional but Important)',
        content: (
            <>
                <p className="mb-4">The built-in `fs` module provides an API for interacting with the file system. It has both synchronous and asynchronous methods.</p>
                <CodeBlock language="javascript" code={`const fs = require('fs');

// Asynchronous file read (non-blocking)
fs.readFile('my-file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log("Async Read:", data);
});

// Synchronous file read (blocks execution)
try {
  const data = fs.readFileSync('my-file.txt', 'utf8');
  console.log("Sync Read:", data);
} catch (err) {
  console.error(err);
}`} />
            </>
        )
    },
    {
        id: 'js-node-events',
        title: 'Events',
        parent: '15. Node.js (Optional but Important)',
        content: (
            <p>Many objects in Node.js emit events. For example, a web server might emit an event for each request. The `EventEmitter` class is at the core of Node's asynchronous event-driven architecture.</p>
        )
    },
    {
        id: 'js-node-streams',
        title: 'Streams',
        parent: '15. Node.js (Optional but Important)',
        content: (
            <p>Streams are objects that let you read data from a source or write data to a destination in a continuous fashion. They are used for handling large amounts of data, like reading a large file or streaming video, without loading it all into memory at once.</p>
        )
    },
    {
        id: 'js-node-express',
        title: 'Express.js basics',
        parent: '15. Node.js (Optional but Important)',
        content: (
            <>
                <p className="mb-4">Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. It's the de facto standard for building APIs and web servers with Node.js.</p>
                <CodeBlock language="javascript" code={`const express = require('express');
const app = express();
const port = 3000;

// Define a route for the homepage
app.get('/', (req, res) => {
  res.send('Hello from CodeAlpha with Express!');
});

// Define a route with a parameter
app.get('/users/:id', (req, res) => {
    res.send('Fetching user with ID: ' + req.params.id);
});

// Start the server
app.listen(port, () => {
  console.log(\`Server listening on http://localhost:\${port}\`);
});`} />
            </>
        )
    },
    // 16. Tooling
    {
        id: 'js-tooling-webpack',
        title: 'Webpack',
        parent: '16. Tooling',
        content: (
            <p>Webpack is a powerful and highly configurable module bundler. It crawls your application, looking for `import` and `require` statements, and bundles all of those modules and their dependencies into one or more output files for the browser.</p>
        )
    },
    {
        id: 'js-tooling-babel',
        title: 'Babel',
        parent: '16. Tooling',
        content: (
            <>
                <p className="mb-4">A transpiler is a tool that converts source code from one language to another. <strong>Babel</strong> is a JavaScript transpiler that is mainly used to convert modern JavaScript (ES6+) code into a backwards-compatible version that can be run by older browsers.</p>
                <CodeBlock language="javascript" code={`// You write modern ES6+ code:
const greet = (name) => \`Hello, \${name}!\`;

// Babel transpiles it to ES5 for older browsers:
"use strict";

var greet = function greet(name) {
  return "Hello, ".concat(name, "!");
};`} />
            </>
        )
    },
    {
        id: 'js-tooling-vite',
        title: 'Vite',
        parent: '16. Tooling',
        content: (
            <>
                <p className="mb-4">Vite is a modern build tool that focuses on speed and developer experience. It uses native ES modules in the browser during development, avoiding the need to bundle the entire application for every change, resulting in lightning-fast updates.</p>
                <pre className="bg-slate-100 p-4 rounded-lg text-sm text-slate-600 my-6 font-mono">
{`// Dev Server Comparison

// Webpack Dev Server:
// 1. Change a file.
// 2. Webpack re-bundles a large chunk of your app.
// 3. Browser reloads. (Can be slow for large apps)

// Vite Dev Server:
// 1. Change a file.
// 2. Vite tells the browser which single module has changed.
// 3. Browser requests only that one module. (Extremely fast)`}
                </pre>
            </>
        )
    },
    {
        id: 'js-tooling-linters',
        title: 'ESLint & Prettier',
        parent: '16. Tooling',
        content: (
            <>
                <p className="mb-4">These tools help maintain code quality and consistency across a team.</p>
                <ul className="list-disc pl-5 space-y-2 mb-4">
                    <li><strong>ESLint:</strong> A static code analysis tool for identifying and reporting on problematic patterns found in JavaScript code. It can find bugs, enforce coding standards, and improve code quality.</li>
                    <li><strong>Prettier:</strong> An opinionated code formatter. It enforces a consistent style by parsing your code and re-printing it with its own rules, saving you time and ending debates about code style.</li>
                </ul>
            </>
        )
    },
    // 17. Testing
    {
        id: 'js-testing-jest',
        title: 'Jest',
        parent: '17. Testing',
        content: (
            <>
                <p className="mb-4">Jest is a popular, zero-configuration testing framework developed by Facebook. It comes with a built-in assertion library, mocking support, and a test runner for unit testing.</p>
                 <CodeBlock language="javascript" code={`// A simple function to test (e.g., in sum.js)
function sum(a, b) {
  return a + b;
}
module.exports = sum;

// The test file (e.g., sum.test.js)
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  // expect() is the assertion function
  // .toBe() is a "matcher"
  expect(sum(1, 2)).toBe(3);
});`} />
            </>
        )
    },
    {
        id: 'js-testing-mocha',
        title: 'Mocha/Chai',
        parent: '17. Testing',
        content: (
            <p>Mocha is a flexible test framework, while Chai is an assertion library that is often used with it. Unlike Jest, they are separate tools that you combine.</p>
        )
    },
    {
        id: 'js-testing-unit',
        title: 'Unit Testing Basics',
        parent: '17. Testing',
        content: (
            <p>Unit testing is the practice of testing small, isolated pieces of code (units) to ensure they work correctly. This helps catch bugs early and makes code easier to refactor.</p>
        )
    },
    // 18. Security (Modern Topics)
    {
        id: 'js-security-xss',
        title: 'XSS',
        parent: '18. Security',
        content: (
            <>
                <p className="mb-4">XSS (Cross-Site Scripting) is a vulnerability where an attacker injects malicious scripts into a web page viewed by other users. The #1 rule to prevent this is to <strong>never trust user input</strong> and always sanitize or escape it before rendering it on a page.</p>
                <div className="bg-red-50 border-l-4 border-red-500 p-4 my-6">
                    <h4 className="font-bold text-red-900 mb-1">Vulnerable Code</h4>
                    <CodeBlock language="javascript" code={`const userInput = '<img src="x" onerror="alert(\'XSS Attack!\')">';
const container = document.getElementById('comment-section');
// Using innerHTML executes the malicious script
container.innerHTML = userInput;`} />
                </div>
                <div className="bg-green-50 border-l-4 border-green-500 p-4 my-6">
                    <h4 className="font-bold text-green-900 mb-1">Secure Code</h4>
                    <CodeBlock language="javascript" code={`const userInput = '<img src="x" onerror="alert(\'XSS Attack!\')">';
const container = document.getElementById('comment-section');
// Using textContent treats the input as plain text
container.textContent = userInput;`} />
                </div>
            </>
        )
    },
    {
        id: 'js-security-csrf',
        title: 'CSRF',
        parent: '18. Security',
        content: (
            <p>CSRF (Cross-Site Request Forgery) is an attack that tricks a user into submitting a malicious request. It inherits the identity and privileges of the victim to perform an undesired function on their behalf. Protection typically involves using anti-CSRF tokens.</p>
        )
    },
    {
        id: 'js-security-sanitization',
        title: 'Sanitization',
        parent: '18. Security',
        content: (
            <p>Input sanitization is the process of cleaning and filtering user input to prevent malicious data from entering your system. This is a crucial step in preventing XSS, SQL Injection, and other vulnerabilities.</p>
        )
    },
    {
        id: 'js-security-cookies',
        title: 'Secure Cookies',
        parent: '18. Security',
        content: (
            <p>When setting cookies for authentication, use the `HttpOnly`, `Secure`, and `SameSite` flags to protect them from being stolen by XSS attacks or sent in cross-site requests.</p>
        )
    },
    {
        id: 'js-security-jwt',
        title: 'Token-based Auth (JWT)',
        parent: '18. Security',
        content: (
            <>
                <p className="mb-4">JSON Web Tokens (JWT) are a standard for securely transmitting information between parties as a JSON object. They are commonly used for authentication. After a user logs in, the server creates a JWT and sends it to the client. The client then includes this token in the `Authorization` header for subsequent requests to access protected resources.</p>
                <pre className="bg-slate-100 p-4 rounded-lg text-sm text-slate-600 my-6 font-mono">
                    {`// JWT Authentication Flow

// 1. Client: POST /login {username, password}
// 2. Server: Verifies credentials, creates JWT, returns token
// 3. Client: Stores JWT (e.g., in localStorage)
// 4. Client: GET /protected-data
//           Header -> Authorization: Bearer <the_jwt_token>
// 5. Server: Verifies JWT signature, returns protected data`}
                </pre>
            </>
        )
    },
];
